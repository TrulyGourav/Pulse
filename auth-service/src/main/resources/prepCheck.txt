## Why do we store ROLE_XXX instead of just USER or ADMIN?
Spring Security internally expects roles to be prefixed with ROLE_, so using it explicitly avoids hidden magic and access-control bugs.

## Why do we NOT return the User entity directly from the controller?
Because entities are persistence models, not API contracts.

Returning entities directly can:
Expose sensitive fields (like password hashes)
Couple API responses tightly to database schema
Break clients when internal fields change
Cause lazy-loading / serialization issues

üëâ Best practice:
Use DTOs to control what data is exposed and keep layers decoupled.

## Why do we add JwtFilter before UsernamePasswordAuthenticationFilter?
We add JwtFilter before UsernamePasswordAuthenticationFilter so JWT-based authentication is processed first, instead of Spring Security‚Äôs default username/password (form login) mechanism.

## How do refresh tokens work?
We use short-lived access tokens for authorization and long-lived refresh tokens to reissue access tokens without re-authentication. This reduces security risk while maintaining good user experience.

In production, refresh tokens should be stored securely and rotated, often backed by Redis or database for revocation.

## Why do we use eventType as Kafka message key?
The message key decides the partition in Kafka. Kafka does this internally:
partition = hash(key) % number_of_partitions

Same key ‚Üí same partition
Same partition ‚Üí order is guaranteed

## What if we didn‚Äôt use a key?
If key = null:

- Kafka distributes messages randomly
- No ordering guarantee
- Harder analytics

## Why do we use 'auto-offset-reset=earliest' in analytics systems?
Because it allows the consumer to replay all past events from the beginning when there is no committed offset.
‚ÄúWe use auto-offset-reset=earliest so analytics consumers can replay historical data when needed.‚Äù


